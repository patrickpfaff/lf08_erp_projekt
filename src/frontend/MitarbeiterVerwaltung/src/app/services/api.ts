//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.8.0 (NJsonSchema v11.0.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class MVApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Test-Endpoint
     * @return Successful Response
     */
    test(): Observable<any> {
        let url_ = this.baseUrl + "/test/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processTest(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get-All-Abteilungen
     * @return Successful Response
     */
    get_all_abteilungen(): Observable<Abteilung[]> {
        let url_ = this.baseUrl + "/get_all_abteilungen/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet_all_abteilungen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet_all_abteilungen(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Abteilung[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Abteilung[]>;
        }));
    }

    protected processGet_all_abteilungen(response: HttpResponseBase): Observable<Abteilung[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Abteilung.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Add-Abteilung
     * @param leiterId (optional) 
     * @param custom_id (optional) 
     * @return Successful Response
     */
    add_abteilung(beschreibung: string, name: string, leiterId: number | undefined, custom_id: number | undefined): Observable<any> {
        let url_ = this.baseUrl + "/add_abteilung/?";
        if (beschreibung === undefined || beschreibung === null)
            throw new Error("The parameter 'beschreibung' must be defined and cannot be null.");
        else
            url_ += "beschreibung=" + encodeURIComponent("" + beschreibung) + "&";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (leiterId === null)
            throw new Error("The parameter 'leiterId' cannot be null.");
        else if (leiterId !== undefined)
            url_ += "leiterId=" + encodeURIComponent("" + leiterId) + "&";
        if (custom_id === null)
            throw new Error("The parameter 'custom_id' cannot be null.");
        else if (custom_id !== undefined)
            url_ += "custom_id=" + encodeURIComponent("" + custom_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd_abteilung(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd_abteilung(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processAdd_abteilung(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete-Abteilung
     * @return Successful Response
     */
    delete_abteilung(id: number): Observable<any> {
        let url_ = this.baseUrl + "/delete_abteilung/?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete_abteilung(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete_abteilung(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDelete_abteilung(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get-Abteilung-By-Id
     * @return Successful Response
     */
    get_abteilung_by_id(id: number): Observable<Abteilung> {
        let url_ = this.baseUrl + "/get_abteilung_by_id/?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet_abteilung_by_id(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet_abteilung_by_id(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Abteilung>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Abteilung>;
        }));
    }

    protected processGet_abteilung_by_id(response: HttpResponseBase): Observable<Abteilung> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Abteilung.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get-All-Mitarbeiter
     * @return Successful Response
     */
    get_all_mitarbeiter(): Observable<Mitarbeiter[]> {
        let url_ = this.baseUrl + "/get_all_mitarbeiter/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet_all_mitarbeiter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet_all_mitarbeiter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Mitarbeiter[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Mitarbeiter[]>;
        }));
    }

    protected processGet_all_mitarbeiter(response: HttpResponseBase): Observable<Mitarbeiter[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Mitarbeiter.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get-Mitarbeiter-By-Id
     * @return Successful Response
     */
    get_mitarbeiter_by_id(id: number): Observable<Mitarbeiter> {
        let url_ = this.baseUrl + "/get_mitarbeiter_by_id/?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet_mitarbeiter_by_id(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet_mitarbeiter_by_id(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Mitarbeiter>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Mitarbeiter>;
        }));
    }

    protected processGet_mitarbeiter_by_id(response: HttpResponseBase): Observable<Mitarbeiter> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Mitarbeiter.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get-Mitarbeiter-By-Name
     * @return Successful Response
     */
    get_mitarbeiter_by_name(vorname: string, nachname: string): Observable<Mitarbeiter[]> {
        let url_ = this.baseUrl + "/get_mitarbeiter_by_name/?";
        if (vorname === undefined || vorname === null)
            throw new Error("The parameter 'vorname' must be defined and cannot be null.");
        else
            url_ += "vorname=" + encodeURIComponent("" + vorname) + "&";
        if (nachname === undefined || nachname === null)
            throw new Error("The parameter 'nachname' must be defined and cannot be null.");
        else
            url_ += "nachname=" + encodeURIComponent("" + nachname) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet_mitarbeiter_by_name(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet_mitarbeiter_by_name(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Mitarbeiter[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Mitarbeiter[]>;
        }));
    }

    protected processGet_mitarbeiter_by_name(response: HttpResponseBase): Observable<Mitarbeiter[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Mitarbeiter.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update-Mitarbeiter
     * @param strasse (optional) 
     * @param hausnummer (optional) 
     * @param zusatz (optional) 
     * @param plz (optional) 
     * @return Successful Response
     */
    update_mitarbeiter(id: number, vorname: string, nachname: string, geburtsdatum: string, angestelltseit: string, jobId: number, abteilungId: number, strasse: string | undefined, hausnummer: string | undefined, zusatz: string | undefined, plz: string | undefined): Observable<any> {
        let url_ = this.baseUrl + "/update_mitarbeiter/?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (vorname === undefined || vorname === null)
            throw new Error("The parameter 'vorname' must be defined and cannot be null.");
        else
            url_ += "vorname=" + encodeURIComponent("" + vorname) + "&";
        if (nachname === undefined || nachname === null)
            throw new Error("The parameter 'nachname' must be defined and cannot be null.");
        else
            url_ += "nachname=" + encodeURIComponent("" + nachname) + "&";
        if (geburtsdatum === undefined || geburtsdatum === null)
            throw new Error("The parameter 'geburtsdatum' must be defined and cannot be null.");
        else
            url_ += "geburtsdatum=" + encodeURIComponent("" + geburtsdatum) + "&";
        if (angestelltseit === undefined || angestelltseit === null)
            throw new Error("The parameter 'angestelltseit' must be defined and cannot be null.");
        else
            url_ += "angestelltseit=" + encodeURIComponent("" + angestelltseit) + "&";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined and cannot be null.");
        else
            url_ += "jobId=" + encodeURIComponent("" + jobId) + "&";
        if (abteilungId === undefined || abteilungId === null)
            throw new Error("The parameter 'abteilungId' must be defined and cannot be null.");
        else
            url_ += "abteilungId=" + encodeURIComponent("" + abteilungId) + "&";
        if (strasse === null)
            throw new Error("The parameter 'strasse' cannot be null.");
        else if (strasse !== undefined)
            url_ += "strasse=" + encodeURIComponent("" + strasse) + "&";
        if (hausnummer === null)
            throw new Error("The parameter 'hausnummer' cannot be null.");
        else if (hausnummer !== undefined)
            url_ += "hausnummer=" + encodeURIComponent("" + hausnummer) + "&";
        if (zusatz === null)
            throw new Error("The parameter 'zusatz' cannot be null.");
        else if (zusatz !== undefined)
            url_ += "zusatz=" + encodeURIComponent("" + zusatz) + "&";
        if (plz === null)
            throw new Error("The parameter 'plz' cannot be null.");
        else if (plz !== undefined)
            url_ += "plz=" + encodeURIComponent("" + plz) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate_mitarbeiter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate_mitarbeiter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processUpdate_mitarbeiter(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Add-Mitarbeiter
     * @param strasse (optional) 
     * @param hausnummer (optional) 
     * @param zusatz (optional) 
     * @param plz (optional) 
     * @return Successful Response
     */
    add_mitarbeiter(vorname: string, nachname: string, geburtsdatum: string, angestelltseit: string, jobId: number, abteilungId: number, strasse: string | undefined, hausnummer: string | undefined, zusatz: string | undefined, plz: string | undefined): Observable<any> {
        let url_ = this.baseUrl + "/add_mitarbeiter/?";
        if (vorname === undefined || vorname === null)
            throw new Error("The parameter 'vorname' must be defined and cannot be null.");
        else
            url_ += "vorname=" + encodeURIComponent("" + vorname) + "&";
        if (nachname === undefined || nachname === null)
            throw new Error("The parameter 'nachname' must be defined and cannot be null.");
        else
            url_ += "nachname=" + encodeURIComponent("" + nachname) + "&";
        if (geburtsdatum === undefined || geburtsdatum === null)
            throw new Error("The parameter 'geburtsdatum' must be defined and cannot be null.");
        else
            url_ += "geburtsdatum=" + encodeURIComponent("" + geburtsdatum) + "&";
        if (angestelltseit === undefined || angestelltseit === null)
            throw new Error("The parameter 'angestelltseit' must be defined and cannot be null.");
        else
            url_ += "angestelltseit=" + encodeURIComponent("" + angestelltseit) + "&";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined and cannot be null.");
        else
            url_ += "jobId=" + encodeURIComponent("" + jobId) + "&";
        if (abteilungId === undefined || abteilungId === null)
            throw new Error("The parameter 'abteilungId' must be defined and cannot be null.");
        else
            url_ += "abteilungId=" + encodeURIComponent("" + abteilungId) + "&";
        if (strasse === null)
            throw new Error("The parameter 'strasse' cannot be null.");
        else if (strasse !== undefined)
            url_ += "strasse=" + encodeURIComponent("" + strasse) + "&";
        if (hausnummer === null)
            throw new Error("The parameter 'hausnummer' cannot be null.");
        else if (hausnummer !== undefined)
            url_ += "hausnummer=" + encodeURIComponent("" + hausnummer) + "&";
        if (zusatz === null)
            throw new Error("The parameter 'zusatz' cannot be null.");
        else if (zusatz !== undefined)
            url_ += "zusatz=" + encodeURIComponent("" + zusatz) + "&";
        if (plz === null)
            throw new Error("The parameter 'plz' cannot be null.");
        else if (plz !== undefined)
            url_ += "plz=" + encodeURIComponent("" + plz) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd_mitarbeiter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd_mitarbeiter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processAdd_mitarbeiter(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete-Mitarbeiter
     * @return Successful Response
     */
    delete_mitarbeiter(id: number): Observable<any> {
        let url_ = this.baseUrl + "/delete_mitarbeiter/?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete_mitarbeiter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete_mitarbeiter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDelete_mitarbeiter(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get-All-Jobs
     * @return Successful Response
     */
    get_all_jobs(): Observable<Job[]> {
        let url_ = this.baseUrl + "/get_all_jobs/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet_all_jobs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet_all_jobs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Job[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Job[]>;
        }));
    }

    protected processGet_all_jobs(response: HttpResponseBase): Observable<Job[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Job.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Add-Job
     * @return Successful Response
     */
    add_job(titel: string): Observable<any> {
        let url_ = this.baseUrl + "/add_job/?";
        if (titel === undefined || titel === null)
            throw new Error("The parameter 'titel' must be defined and cannot be null.");
        else
            url_ += "titel=" + encodeURIComponent("" + titel) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd_job(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd_job(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processAdd_job(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete-Job
     * @return Successful Response
     */
    delete_job(id: number): Observable<any> {
        let url_ = this.baseUrl + "/delete_job/?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete_job(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete_job(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDelete_job(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get-Job-By-Id
     * @return Successful Response
     */
    get_job_by_id(id: number): Observable<Job> {
        let url_ = this.baseUrl + "/get_job_by_id/?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet_job_by_id(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet_job_by_id(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Job>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Job>;
        }));
    }

    protected processGet_job_by_id(response: HttpResponseBase): Observable<Job> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Job.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get-All-Adressen
     * @return Successful Response
     */
    get_all_adressen(): Observable<Adresse[]> {
        let url_ = this.baseUrl + "/get_all_adressen/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet_all_adressen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet_all_adressen(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Adresse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Adresse[]>;
        }));
    }

    protected processGet_all_adressen(response: HttpResponseBase): Observable<Adresse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Adresse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Add-Adresse
     * @return Successful Response
     */
    add_adresse(strasse: string, hausnummer: string, zusatz: string, plz: string): Observable<any> {
        let url_ = this.baseUrl + "/add_adresse/?";
        if (strasse === undefined || strasse === null)
            throw new Error("The parameter 'strasse' must be defined and cannot be null.");
        else
            url_ += "strasse=" + encodeURIComponent("" + strasse) + "&";
        if (hausnummer === undefined || hausnummer === null)
            throw new Error("The parameter 'hausnummer' must be defined and cannot be null.");
        else
            url_ += "hausnummer=" + encodeURIComponent("" + hausnummer) + "&";
        if (zusatz === undefined || zusatz === null)
            throw new Error("The parameter 'zusatz' must be defined and cannot be null.");
        else
            url_ += "zusatz=" + encodeURIComponent("" + zusatz) + "&";
        if (plz === undefined || plz === null)
            throw new Error("The parameter 'plz' must be defined and cannot be null.");
        else
            url_ += "plz=" + encodeURIComponent("" + plz) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd_adresse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd_adresse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processAdd_adresse(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete-Adresse
     * @return Successful Response
     */
    delete_adresse(id: number): Observable<any> {
        let url_ = this.baseUrl + "/delete_adresse/?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete_adresse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete_adresse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDelete_adresse(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get-Adresse-By-Id
     * @return Successful Response
     */
    get_adresse_by_id(id: number): Observable<Adresse> {
        let url_ = this.baseUrl + "/get_adresse_by_id/?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet_adresse_by_id(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet_adresse_by_id(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Adresse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Adresse>;
        }));
    }

    protected processGet_adresse_by_id(response: HttpResponseBase): Observable<Adresse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Adresse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get-Ortsname-From-Plz
     * @return Successful Response
     */
    get_ortsname_from_plz(plz: string): Observable<string> {
        let url_ = this.baseUrl + "/get_ortsname_from_plz/?";
        if (plz === undefined || plz === null)
            throw new Error("The parameter 'plz' must be defined and cannot be null.");
        else
            url_ += "plz=" + encodeURIComponent("" + plz) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet_ortsname_from_plz(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet_ortsname_from_plz(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGet_ortsname_from_plz(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = HTTPValidationError.fromJS(resultData422);
            return throwException("Validation Error", status, _responseText, _headers, result422);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class Abteilung implements IAbteilung {
    id?: number;
    name!: string;
    beschreibung!: string;
    leiterId!: LeiterId;

    [key: string]: any;

    constructor(data?: IAbteilung) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.beschreibung = _data["beschreibung"];
            this.leiterId = _data["leiterId"];
        }
    }

    static fromJS(data: any): Abteilung {
        data = typeof data === 'object' ? data : {};
        let result = new Abteilung();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["beschreibung"] = this.beschreibung;
        data["leiterId"] = this.leiterId;
        return data;
    }
}

export interface IAbteilung {
    id?: number;
    name: string;
    beschreibung: string;
    leiterId: LeiterId;

    [key: string]: any;
}

export class Adresse implements IAdresse {
    id?: number;
    strasse!: string;
    hausnummer!: string;
    zusatz!: string;
    plz!: string;

    [key: string]: any;

    constructor(data?: IAdresse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.strasse = _data["strasse"];
            this.hausnummer = _data["hausnummer"];
            this.zusatz = _data["zusatz"];
            this.plz = _data["plz"];
        }
    }

    static fromJS(data: any): Adresse {
        data = typeof data === 'object' ? data : {};
        let result = new Adresse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["strasse"] = this.strasse;
        data["hausnummer"] = this.hausnummer;
        data["zusatz"] = this.zusatz;
        data["plz"] = this.plz;
        return data;
    }
}

export interface IAdresse {
    id?: number;
    strasse: string;
    hausnummer: string;
    zusatz: string;
    plz: string;

    [key: string]: any;
}

export class HTTPValidationError implements IHTTPValidationError {
    detail?: ValidationError[];

    [key: string]: any;

    constructor(data?: IHTTPValidationError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["detail"])) {
                this.detail = [] as any;
                for (let item of _data["detail"])
                    this.detail!.push(ValidationError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HTTPValidationError {
        data = typeof data === 'object' ? data : {};
        let result = new HTTPValidationError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.detail)) {
            data["detail"] = [];
            for (let item of this.detail)
                data["detail"].push(item.toJSON());
        }
        return data;
    }
}

export interface IHTTPValidationError {
    detail?: ValidationError[];

    [key: string]: any;
}

export class Job implements IJob {
    id?: number;
    titel!: string;

    [key: string]: any;

    constructor(data?: IJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.titel = _data["titel"];
        }
    }

    static fromJS(data: any): Job {
        data = typeof data === 'object' ? data : {};
        let result = new Job();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["titel"] = this.titel;
        return data;
    }
}

export interface IJob {
    id?: number;
    titel: string;

    [key: string]: any;
}

export class Mitarbeiter implements IMitarbeiter {
    id?: number;
    nachname!: string;
    vorname!: string;
    geburtsdatum!: string;
    angestelltseit!: string;
    jobId!: number;
    abteilungId!: number;
    adresseId!: number;

    [key: string]: any;

    constructor(data?: IMitarbeiter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.nachname = _data["nachname"];
            this.vorname = _data["vorname"];
            this.geburtsdatum = _data["geburtsdatum"];
            this.angestelltseit = _data["angestelltseit"];
            this.jobId = _data["jobId"];
            this.abteilungId = _data["abteilungId"];
            this.adresseId = _data["adresseId"];
        }
    }

    static fromJS(data: any): Mitarbeiter {
        data = typeof data === 'object' ? data : {};
        let result = new Mitarbeiter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["nachname"] = this.nachname;
        data["vorname"] = this.vorname;
        data["geburtsdatum"] = this.geburtsdatum;
        data["angestelltseit"] = this.angestelltseit;
        data["jobId"] = this.jobId;
        data["abteilungId"] = this.abteilungId;
        data["adresseId"] = this.adresseId;
        return data;
    }
}

export interface IMitarbeiter {
    id?: number;
    nachname: string;
    vorname: string;
    geburtsdatum: string;
    angestelltseit: string;
    jobId: number;
    abteilungId: number;
    adresseId: number;

    [key: string]: any;
}

export class ValidationError implements IValidationError {
    loc!: Loc[];
    msg!: string;
    type!: string;

    [key: string]: any;

    constructor(data?: IValidationError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.loc = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["loc"])) {
                this.loc = [] as any;
                for (let item of _data["loc"])
                    this.loc!.push(item);
            }
            this.msg = _data["msg"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ValidationError {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.loc)) {
            data["loc"] = [];
            for (let item of this.loc)
                data["loc"].push(item);
        }
        data["msg"] = this.msg;
        data["type"] = this.type;
        return data;
    }
}

export interface IValidationError {
    loc: Loc[];
    msg: string;
    type: string;

    [key: string]: any;
}

export class LeiterId implements ILeiterId {

    [key: string]: any;

    constructor(data?: ILeiterId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): LeiterId {
        data = typeof data === 'object' ? data : {};
        let result = new LeiterId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ILeiterId {

    [key: string]: any;
}

export class Loc implements ILoc {

    [key: string]: any;

    constructor(data?: ILoc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Loc {
        data = typeof data === 'object' ? data : {};
        let result = new Loc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ILoc {

    [key: string]: any;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}